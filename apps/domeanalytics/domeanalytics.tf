module "label" {
  source = "github.com/mitlibraries/tf-mod-name?ref=0.12"
  name   = "domeanalytics"
}

resource "aws_security_group" "default" {
  name        = "${module.label.name}-sg"
  description = "${module.label.name} ec2 security group"
  tags        = module.label.tags
  vpc_id      = module.shared.vpc_id

  # Limit SSH to MITNet
  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = var.sec_ssh_access_subnets
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# Here we assign an Elastic IP address. The reason we do this is because this
# ec2 instance will have a secondary usage for downloading data from external
# vendor sites that use IP ACL authentication. Default AWS external IP
# assignments by Amazon's DHCP server remain static while the instance is
# running. However, if the instance is not (suspected, terminated, etc) a new
# IP address may be assigned by Amazon's DHCP server. On the other hand if
# an Elastic IP address is used with the instance, the IP address will not
# change. Since a change in IP address (source IP for external traffic as
# seen by a receiving host) would mean a human communication with one or more
# vendors to update IP ACLs, we incur the expense of using an Elastic IP for
# this ec2 instance.
resource "aws_eip" "default" {
  instance = aws_instance.default.id
  vpc      = true
}

resource "aws_efs_file_system" "default" {
  creation_token = "${module.label.name}-efs"
  tags           = module.label.tags

  encrypted      = true
}

resource "aws_efs_mount_target" "default" {
  file_system_id  = aws_efs_file_system.default.id
  subnet_id       = var.efs_subnet
  security_groups = [aws_security_group.efs.id]
}

resource "aws_security_group" "efs" {
  name        = "${module.label.name}-efs-sg"
  description = "EFS security group"
  tags        = module.label.tags
  vpc_id      = module.shared.vpc_id

  ingress {
    from_port       = 2049
    to_port         = 2049
    protocol        = "tcp"
    security_groups = [aws_security_group.default.id]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# Export Terraform variable values to an Ansible var_file
resource "local_file" "tf_ansible_vars_file_new" {
  content = <<-DOC
    # Ansible vars_file containing variable values from Terraform.
    # Generated by Terraform mgmt configuration.

    tf_mountpoint: ${var.efs_mount}
    tf_efs_target: ${aws_efs_file_system.default.dns_name}
    DOC
  filename = "./ansible/roles/domeanalytics/vars/tf_ansible_vars_file.yml"
}

# Export Terraform IP information to Ansible inventory file
resource "local_file" "inventories" {
  content = <<-DOC
    [domeanalytics-all]
    ${ aws_eip.default.public_ip }
    DOC
  filename = "./ansible/staging"
}

# This is a very standard small ec2 instance with little storage. The root
# block device (attached virtual disk) should only be used to store operating
# system data, variable data, and log data. User data such as reports and
# datasets should be stored on the EFS partition. The EFS storage is much
# easier to grow/expand and less expensive (especially when tiered storage is
# enabled).
resource "aws_instance" "default" {
  tags          = module.label.tags
  instance_type = var.ec2_inst_type
  ami           = var.ec2_ami
  subnet_id     = var.ec2_subnet

  vpc_security_group_ids = [aws_security_group.default.id]
  key_name               = var.ec2_key_name
  ebs_optimized          = true

  root_block_device {
    volume_size = var.ec2_vol_size
    volume_type = var.ec2_vol_type
    encrypted   = true
  }

  # Here we're calling remote-exec to run a trivial command on the newly
  # created ec2 instance. The reason we're doing this is that TerraForm
  # will block execution until the ec2 instance is fully spun up and
  # available. TerraForm will not block execution on a local-exec provisioner.
  # So, if we skipped this remove-exec call and went directly to run our ansible
  # code it could fail because the instance wouldn't be fully available yet. This
  # hack ensures that it is. Although, because we are creating Route53 records
  # before attempting to reach the host it should be since Route53 records take
  # a long time to provision. But, this will allow for more reliable execution
  # especially when we are running the code to modify the instance (when it
  # already has its Route53 records allocated) rather that create it for the
  # first time.
  provisioner "remote-exec" {
    inline = ["sudo apt-get install python-is-python3 -y"]

    connection {
      host        = self.public_ip
      type        = "ssh"
      user        = "ubuntu"
      private_key = file(var.ssh_key_private)
    }
  }

  # Here we're finally running the Ansible code included in the app directory
  # because we're sure the instance is now available for remote ssh connections.
  provisioner "local-exec" {
    command = "ansible-playbook -u ubuntu -i '${self.public_ip},' --private-key ${var.ssh_key_private} ./ansible/site.yml"
  }
}

# This is the private IP that people will use to connect to this host from
# inside the VPC. This could be ssh connections from the bastion hosts, from
# other servers, or other AWS systems like Lambda, inside the same VPC.
resource "aws_route53_record" "private" {
  name    = module.label.name
  zone_id = var.r53_internal_zone_id
  type    = "A"
  ttl     = "300"

  records = [aws_instance.default.private_ip]
}

# This is the public IP that people will use to connect to the system from
# outside the VPC. We're currently creating this record because we're going
# to allow ssh connections from the MIT VPN. Eventually, we may want to limit
# connections instead to the VPC bastion hosts in order to improve security.
# If we did that, an external DNS record would be unnecessary since all
# traffic would originate inside the host's VPC.
resource "aws_route53_record" "default" {
  name    = module.label.name
  zone_id = var.r53_external_zone_id
  type    = "A"
  ttl     = "300"

  records = [aws_eip.default.public_ip]
}
